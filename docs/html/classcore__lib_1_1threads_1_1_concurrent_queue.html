<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Core Library: core_lib::threads::ConcurrentQueue&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Core Library
   &#160;<span id="projectnumber">1.5.3</span>
   </div>
   <div id="projectbrief">Library containing core utilities and tools for threading, networking, logging, INI and CSV file management etc.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classcore__lib_1_1threads_1_1_concurrent_queue.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classcore__lib_1_1threads_1_1_concurrent_queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">core_lib::threads::ConcurrentQueue&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class defining a concurrent queue.  
 <a href="classcore__lib_1_1threads_1_1_concurrent_queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_concurrent_queue_8h_source.html">ConcurrentQueue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1146e87353baead8d86048cd3f6f2a7e"><td class="memItemLeft" align="right" valign="top"><a id="a1146e87353baead8d86048cd3f6f2a7e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a1146e87353baead8d86048cd3f6f2a7e">container_type</a> = std::deque&lt; T &gt;</td></tr>
<tr class="memdesc:a1146e87353baead8d86048cd3f6f2a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for container type. <br /></td></tr>
<tr class="separator:a1146e87353baead8d86048cd3f6f2a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a86f274141d0410f2b2c979866db1cf67"><td class="memItemLeft" align="right" valign="top"><a id="a86f274141d0410f2b2c979866db1cf67"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a86f274141d0410f2b2c979866db1cf67">ConcurrentQueue</a> ()=default</td></tr>
<tr class="memdesc:a86f274141d0410f2b2c979866db1cf67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a86f274141d0410f2b2c979866db1cf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f99f517b6c4ac7ca74e64fbedfe4ef"><td class="memItemLeft" align="right" valign="top"><a id="ac4f99f517b6c4ac7ca74e64fbedfe4ef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#ac4f99f517b6c4ac7ca74e64fbedfe4ef">ConcurrentQueue</a> (const <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">ConcurrentQueue</a> &amp;)=delete</td></tr>
<tr class="memdesc:ac4f99f517b6c4ac7ca74e64fbedfe4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor deleted. <br /></td></tr>
<tr class="separator:ac4f99f517b6c4ac7ca74e64fbedfe4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb24f09bc37cc42ba84391d7a57d6d52"><td class="memItemLeft" align="right" valign="top"><a id="acb24f09bc37cc42ba84391d7a57d6d52"></a>
<a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">ConcurrentQueue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#acb24f09bc37cc42ba84391d7a57d6d52">operator=</a> (const <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">ConcurrentQueue</a> &amp;)=delete</td></tr>
<tr class="memdesc:acb24f09bc37cc42ba84391d7a57d6d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator deleted. <br /></td></tr>
<tr class="separator:acb24f09bc37cc42ba84391d7a57d6d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c45f034504c64c3b67e6304701356a1"><td class="memItemLeft" align="right" valign="top"><a id="a9c45f034504c64c3b67e6304701356a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a9c45f034504c64c3b67e6304701356a1">ConcurrentQueue</a> (<a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">ConcurrentQueue</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a9c45f034504c64c3b67e6304701356a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor deleted. <br /></td></tr>
<tr class="separator:a9c45f034504c64c3b67e6304701356a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2661fda65eae9fb59b4e09db03b6490b"><td class="memItemLeft" align="right" valign="top"><a id="a2661fda65eae9fb59b4e09db03b6490b"></a>
<a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">ConcurrentQueue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a2661fda65eae9fb59b4e09db03b6490b">operator=</a> (<a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">ConcurrentQueue</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a2661fda65eae9fb59b4e09db03b6490b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator deleted. <br /></td></tr>
<tr class="separator:a2661fda65eae9fb59b4e09db03b6490b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0380520117b67082d955492e22c487ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a0380520117b67082d955492e22c487ea">~ConcurrentQueue</a> ()=default</td></tr>
<tr class="memdesc:a0380520117b67082d955492e22c487ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a0380520117b67082d955492e22c487ea">More...</a><br /></td></tr>
<tr class="separator:a0380520117b67082d955492e22c487ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a86f55f3471566151aef7e9eee5ccd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a71a86f55f3471566151aef7e9eee5ccd">Size</a> () const</td></tr>
<tr class="memdesc:a71a86f55f3471566151aef7e9eee5ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the queue.  <a href="#a71a86f55f3471566151aef7e9eee5ccd">More...</a><br /></td></tr>
<tr class="separator:a71a86f55f3471566151aef7e9eee5ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03344656e7e1eedeea32a16d2695990c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a03344656e7e1eedeea32a16d2695990c">Empty</a> () const</td></tr>
<tr class="memdesc:a03344656e7e1eedeea32a16d2695990c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the queue empty.  <a href="#a03344656e7e1eedeea32a16d2695990c">More...</a><br /></td></tr>
<tr class="separator:a03344656e7e1eedeea32a16d2695990c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc992f1ab10e46088b4190437a5e36b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#afc992f1ab10e46088b4190437a5e36b6">Push</a> (T &amp;&amp;item)</td></tr>
<tr class="memdesc:afc992f1ab10e46088b4190437a5e36b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an item onto the queue.  <a href="#afc992f1ab10e46088b4190437a5e36b6">More...</a><br /></td></tr>
<tr class="separator:afc992f1ab10e46088b4190437a5e36b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6e58f6cf7a554eb7838875c74e59c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a9b6e58f6cf7a554eb7838875c74e59c9">Push</a> (const T &amp;item)</td></tr>
<tr class="memdesc:a9b6e58f6cf7a554eb7838875c74e59c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an item onto the queue.  <a href="#a9b6e58f6cf7a554eb7838875c74e59c9">More...</a><br /></td></tr>
<tr class="separator:a9b6e58f6cf7a554eb7838875c74e59c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3d0e1d8a6dfc60c9f2c5205f12d8c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a7f3d0e1d8a6dfc60c9f2c5205f12d8c5">BreakPopWait</a> ()</td></tr>
<tr class="memdesc:a7f3d0e1d8a6dfc60c9f2c5205f12d8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Break out of waiting on a Pop method.  <a href="#a7f3d0e1d8a6dfc60c9f2c5205f12d8c5">More...</a><br /></td></tr>
<tr class="separator:a7f3d0e1d8a6dfc60c9f2c5205f12d8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0739eb098119d7db6a3e78eb35c2cf2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#ab0739eb098119d7db6a3e78eb35c2cf2">Pop</a> (T &amp;item)</td></tr>
<tr class="memdesc:ab0739eb098119d7db6a3e78eb35c2cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an item off the queue if there are any else wait.  <a href="#ab0739eb098119d7db6a3e78eb35c2cf2">More...</a><br /></td></tr>
<tr class="separator:ab0739eb098119d7db6a3e78eb35c2cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa005fa06cdf70eca7c2f2187811b2a84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#aa005fa06cdf70eca7c2f2187811b2a84">PopThrow</a> (T &amp;item)</td></tr>
<tr class="memdesc:aa005fa06cdf70eca7c2f2187811b2a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an item off the queue if there are any else wait.  <a href="#aa005fa06cdf70eca7c2f2187811b2a84">More...</a><br /></td></tr>
<tr class="separator:aa005fa06cdf70eca7c2f2187811b2a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24340e08122e91037bbc84d2fdc50b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#aa24340e08122e91037bbc84d2fdc50b4">TryPop</a> (T &amp;item)</td></tr>
<tr class="memdesc:aa24340e08122e91037bbc84d2fdc50b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an item off the queue if there are any else return.  <a href="#aa24340e08122e91037bbc84d2fdc50b4">More...</a><br /></td></tr>
<tr class="separator:aa24340e08122e91037bbc84d2fdc50b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518d08e42fdb9613733ac572fcaa4ecf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a518d08e42fdb9613733ac572fcaa4ecf">TryPopThrow</a> (T &amp;item)</td></tr>
<tr class="memdesc:a518d08e42fdb9613733ac572fcaa4ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an item off the queue.  <a href="#a518d08e42fdb9613733ac572fcaa4ecf">More...</a><br /></td></tr>
<tr class="separator:a518d08e42fdb9613733ac572fcaa4ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e80977a24adce8baf939a395a975f19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a2e80977a24adce8baf939a395a975f19">TimedPop</a> (unsigned int timeoutMilliseconds, T &amp;item)</td></tr>
<tr class="memdesc:a2e80977a24adce8baf939a395a975f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an item off the queue but only wait for a given amount of time.  <a href="#a2e80977a24adce8baf939a395a975f19">More...</a><br /></td></tr>
<tr class="separator:a2e80977a24adce8baf939a395a975f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4363dd5fe2e0ee2be4d7cc724699a3f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a4363dd5fe2e0ee2be4d7cc724699a3f5">TimedPopThrow</a> (unsigned int timeoutMilliseconds, T &amp;item)</td></tr>
<tr class="memdesc:a4363dd5fe2e0ee2be4d7cc724699a3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an item off the queue but only wait for a given amount of time.  <a href="#a4363dd5fe2e0ee2be4d7cc724699a3f5">More...</a><br /></td></tr>
<tr class="separator:a4363dd5fe2e0ee2be4d7cc724699a3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a1929f773384c559a3c0bb991255b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a17a1929f773384c559a3c0bb991255b0">TrySteal</a> (T &amp;item)</td></tr>
<tr class="memdesc:a17a1929f773384c559a3c0bb991255b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Steal an item from the back of the queue if there are any else return.  <a href="#a17a1929f773384c559a3c0bb991255b0">More...</a><br /></td></tr>
<tr class="separator:a17a1929f773384c559a3c0bb991255b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6ec6f4828d9bafc2d6bd510ef62e1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a8c6ec6f4828d9bafc2d6bd510ef62e1b">TryStealThrow</a> (T &amp;item)</td></tr>
<tr class="memdesc:a8c6ec6f4828d9bafc2d6bd510ef62e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Steal an item from the back of the queue.  <a href="#a8c6ec6f4828d9bafc2d6bd510ef62e1b">More...</a><br /></td></tr>
<tr class="separator:a8c6ec6f4828d9bafc2d6bd510ef62e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad050498c1ce8652fed6c70bc607c17b0"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#ad050498c1ce8652fed6c70bc607c17b0">Peek</a> (size_t index) const</td></tr>
<tr class="memdesc:ad050498c1ce8652fed6c70bc607c17b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a peek at an item at a given index on the queue.  <a href="#ad050498c1ce8652fed6c70bc607c17b0">More...</a><br /></td></tr>
<tr class="separator:ad050498c1ce8652fed6c70bc607c17b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dad5b5d8a631dbe9151432494144e90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a3dad5b5d8a631dbe9151432494144e90">Clear</a> ()</td></tr>
<tr class="memdesc:a3dad5b5d8a631dbe9151432494144e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the queue.  <a href="#a3dad5b5d8a631dbe9151432494144e90">More...</a><br /></td></tr>
<tr class="separator:a3dad5b5d8a631dbe9151432494144e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c957659057cc6adcaa6e4c6aeb433b"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a76c957659057cc6adcaa6e4c6aeb433b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a76c957659057cc6adcaa6e4c6aeb433b">Clear</a> (F deleter)</td></tr>
<tr class="memdesc:a76c957659057cc6adcaa6e4c6aeb433b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the queue.  <a href="#a76c957659057cc6adcaa6e4c6aeb433b">More...</a><br /></td></tr>
<tr class="separator:a76c957659057cc6adcaa6e4c6aeb433b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af860cec5b94be5c143d4df77a7caa39f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a1146e87353baead8d86048cd3f6f2a7e">container_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#af860cec5b94be5c143d4df77a7caa39f">TakeAll</a> ()</td></tr>
<tr class="memdesc:af860cec5b94be5c143d4df77a7caa39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take all items from the queue and return them, thus clearing down the internal queue.  <a href="#af860cec5b94be5c143d4df77a7caa39f">More...</a><br /></td></tr>
<tr class="separator:af860cec5b94be5c143d4df77a7caa39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a2cdf8c31f8359021a9fdbf3a10d46c66"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a2cdf8c31f8359021a9fdbf3a10d46c66">eQueueEnd</a> { <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a2cdf8c31f8359021a9fdbf3a10d46c66ae6ec529ba185279aa0adcf93e645c7cd">eQueueEnd::front</a>, 
<a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a2cdf8c31f8359021a9fdbf3a10d46c66a469bba0a564235dfceede42db14f17b0">eQueueEnd::back</a>
 }</td></tr>
<tr class="memdesc:a2cdf8c31f8359021a9fdbf3a10d46c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration controlling end of queue to pop from.  <a href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a2cdf8c31f8359021a9fdbf3a10d46c66">More...</a><br /></td></tr>
<tr class="separator:a2cdf8c31f8359021a9fdbf3a10d46c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a283c60060231a49bc3a7c8e6afcb06f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a283c60060231a49bc3a7c8e6afcb06f6">PopNow</a> (T &amp;item, <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a2cdf8c31f8359021a9fdbf3a10d46c66">eQueueEnd</a> whichEnd=<a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a2cdf8c31f8359021a9fdbf3a10d46c66ae6ec529ba185279aa0adcf93e645c7cd">eQueueEnd::front</a>)</td></tr>
<tr class="memdesc:a283c60060231a49bc3a7c8e6afcb06f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an item off the queue.  <a href="#a283c60060231a49bc3a7c8e6afcb06f6">More...</a><br /></td></tr>
<tr class="separator:a283c60060231a49bc3a7c8e6afcb06f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30195c516adef0e3d84759b051bf5bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#ac30195c516adef0e3d84759b051bf5bd">PopFront</a> (T &amp;item)</td></tr>
<tr class="memdesc:ac30195c516adef0e3d84759b051bf5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an item off the front of the queue.  <a href="#ac30195c516adef0e3d84759b051bf5bd">More...</a><br /></td></tr>
<tr class="separator:ac30195c516adef0e3d84759b051bf5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a808f24042f3f48be0fd94b67ca5e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a69a808f24042f3f48be0fd94b67ca5e4">PopBack</a> (T &amp;item)</td></tr>
<tr class="memdesc:a69a808f24042f3f48be0fd94b67ca5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an item off the back of the queue.  <a href="#a69a808f24042f3f48be0fd94b67ca5e4">More...</a><br /></td></tr>
<tr class="separator:a69a808f24042f3f48be0fd94b67ca5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a295b3ba933953eddcc810a4fdbd83583"><td class="memItemLeft" align="right" valign="top"><a id="a295b3ba933953eddcc810a4fdbd83583"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a295b3ba933953eddcc810a4fdbd83583">m_mutex</a></td></tr>
<tr class="memdesc:a295b3ba933953eddcc810a4fdbd83583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronization mutex. <br /></td></tr>
<tr class="separator:a295b3ba933953eddcc810a4fdbd83583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4eb3c57b9cf483da061255555ae0b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html">SyncEvent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a3f4eb3c57b9cf483da061255555ae0b0">m_itemEvent</a></td></tr>
<tr class="memdesc:a3f4eb3c57b9cf483da061255555ae0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronization event.  <a href="#a3f4eb3c57b9cf483da061255555ae0b0">More...</a><br /></td></tr>
<tr class="separator:a3f4eb3c57b9cf483da061255555ae0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4be4f826b0a554e2d36bdf3d7a2029"><td class="memItemLeft" align="right" valign="top"><a id="a9d4be4f826b0a554e2d36bdf3d7a2029"></a>
<a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a1146e87353baead8d86048cd3f6f2a7e">container_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a9d4be4f826b0a554e2d36bdf3d7a2029">m_queue</a> {}</td></tr>
<tr class="memdesc:a9d4be4f826b0a554e2d36bdf3d7a2029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying deque container acting as the queue. <br /></td></tr>
<tr class="separator:a9d4be4f826b0a554e2d36bdf3d7a2029"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class core_lib::threads::ConcurrentQueue&lt; T &gt;</h3>

<p>Class defining a concurrent queue. </p>
<p>This class implements a fully thread-safe queue that can be used with single/multiple producer thread(s) and single/multiple consumer thread(s).</p>
<p>It is up to the caller to make sure individual queue items get deallocated correctly. Preferably by using RAII objects as queue items or wrapping underlying data in std::shared_ptr (using a custom deallocator if necessary - see example custom deleters: <a class="el" href="structcore__lib_1_1threads_1_1_single_item_deleter.html" title="Single item deleter for queue item. ">SingleItemDeleter</a> and <a class="el" href="structcore__lib_1_1threads_1_1_array_deleter.html" title="Array deleter for queue item. ">ArrayDeleter</a>).</p>
<p>The template T must be a copyable and movable type. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a2cdf8c31f8359021a9fdbf3a10d46c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdf8c31f8359021a9fdbf3a10d46c66">&#9670;&nbsp;</a></span>eQueueEnd</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a2cdf8c31f8359021a9fdbf3a10d46c66">core_lib::threads::ConcurrentQueue::eQueueEnd</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration controlling end of queue to pop from. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2cdf8c31f8359021a9fdbf3a10d46c66ae6ec529ba185279aa0adcf93e645c7cd"></a>front&#160;</td><td class="fielddoc"><p>Pop front of the queue. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2cdf8c31f8359021a9fdbf3a10d46c66a469bba0a564235dfceede42db14f17b0"></a>back&#160;</td><td class="fielddoc"><p>Pop back of the queue. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0380520117b67082d955492e22c487ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0380520117b67082d955492e22c487ea">&#9670;&nbsp;</a></span>~ConcurrentQueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::~<a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">ConcurrentQueue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>If the queue items aren't RAII-like objects and so don't manager their own memory then make sure you call the second Clear method, defined later, that takes a deleter functor to tidy up the memory of each queue item. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7f3d0e1d8a6dfc60c9f2c5205f12d8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3d0e1d8a6dfc60c9f2c5205f12d8c5">&#9670;&nbsp;</a></span>BreakPopWait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::BreakPopWait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Break out of waiting on a Pop method. </p>
<p>Useful to force consumer(s) to break out of wait on Pop etc. </p>

</div>
</div>
<a id="a3dad5b5d8a631dbe9151432494144e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dad5b5d8a631dbe9151432494144e90">&#9670;&nbsp;</a></span>Clear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the queue. </p>
<p>If this method is called while a thread is blocking on the item event then due to interleving of calls and mutex lock timings this may cause the list to be cleared before a waiting pop function has had a chance to pop anything from the queue. This is safe but what it means is the pop function will not find anything to pop and will either throw or return false to indicate that nothing was popped off the queue. </p>

</div>
</div>
<a id="a76c957659057cc6adcaa6e4c6aeb433b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c957659057cc6adcaa6e4c6aeb433b">&#9670;&nbsp;</a></span>Clear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::Clear </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>deleter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deleter</td><td>- If queue items are not RAII objects that will tidy up after themselves then you can pass in a suitable deleter to delete each queue item.</td></tr>
  </table>
  </dd>
</dl>
<p>It is also expected that the queue items are raw pointers.</p>
<p>If this method is called while a thread is blocking on the item event then due to interleving of calls and mutex lock timings this may cause the list to be cleared before a waiting pop function has had a chance to pop anything from the queue. This is safe but what it means is the pop function will not find anything to pop and will either throw or return false to indicate that nothing was popped off the queue. </p>

</div>
</div>
<a id="a03344656e7e1eedeea32a16d2695990c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03344656e7e1eedeea32a16d2695990c">&#9670;&nbsp;</a></span>Empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::Empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the queue empty. </p>
<dl class="section return"><dt>Returns</dt><dd>True if empty, false otherwise. </dd></dl>

</div>
</div>
<a id="ad050498c1ce8652fed6c70bc607c17b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad050498c1ce8652fed6c70bc607c17b0">&#9670;&nbsp;</a></span>Peek()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::Peek </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take a peek at an item at a given index on the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- Zero-based index of the queue item to peek at. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const pointer to item on queue being peeked at.</dd></dl>
<p>This method returns a nullptr if the index does not exist in the queue. The use of this method can be dangerous if there are multiple consumers. or if there is a single consumer but the method is called from a different thread to the consumer. </p>

</div>
</div>
<a id="ab0739eb098119d7db6a3e78eb35c2cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0739eb098119d7db6a3e78eb35c2cf2">&#9670;&nbsp;</a></span>Pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::Pop </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop an item off the queue if there are any else wait. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>- The popped item, only valid if returns true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if item popped off queue, false otherwise.</dd></dl>
<p>Method will block forever or until an item is placed on the queue. </p>

</div>
</div>
<a id="a69a808f24042f3f48be0fd94b67ca5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a808f24042f3f48be0fd94b67ca5e4">&#9670;&nbsp;</a></span>PopBack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::PopBack </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop an item off the back of the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>- Item popped off back. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac30195c516adef0e3d84759b051bf5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30195c516adef0e3d84759b051bf5bd">&#9670;&nbsp;</a></span>PopFront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::PopFront </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop an item off the front of the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>- Item popped off front. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a283c60060231a49bc3a7c8e6afcb06f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283c60060231a49bc3a7c8e6afcb06f6">&#9670;&nbsp;</a></span>PopNow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::PopNow </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a2cdf8c31f8359021a9fdbf3a10d46c66">eQueueEnd</a>&#160;</td>
          <td class="paramname"><em>whichEnd</em> = <code><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a2cdf8c31f8359021a9fdbf3a10d46c66ae6ec529ba185279aa0adcf93e645c7cd">eQueueEnd::front</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop an item off the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>- Item popped off queue. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">whichEnd</td><td>- WHich end of queue tp pop from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if not empty, false if queue empty. </dd></dl>

</div>
</div>
<a id="aa005fa06cdf70eca7c2f2187811b2a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa005fa06cdf70eca7c2f2187811b2a84">&#9670;&nbsp;</a></span>PopThrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::PopThrow </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop an item off the queue if there are any else wait. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>- The popped item, only valid if returns true.</td></tr>
  </table>
  </dd>
</dl>
<p>Method will block forever or until an item is placed on the queue.</p>
<p>This will throw std::runtime_error if there are no items on the queue when called. </p>

</div>
</div>
<a id="afc992f1ab10e46088b4190437a5e36b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc992f1ab10e46088b4190437a5e36b6">&#9670;&nbsp;</a></span>Push() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::Push </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push an item onto the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">item</td><td>- Object of type T to push onto queue.</td></tr>
  </table>
  </dd>
</dl>
<p>The arg item must be moveable either implicitly or by passing it to Push wrapped in a std::move() and item will be invalid once this function returns due to being moved onto the internal queue.</p>
<p>It is preferred to use this version when performance matters as move semantics are enforced. </p>

</div>
</div>
<a id="a9b6e58f6cf7a554eb7838875c74e59c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6e58f6cf7a554eb7838875c74e59c9">&#9670;&nbsp;</a></span>Push() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::Push </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push an item onto the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">item</td><td>- Object of type T to push onto queue.</td></tr>
  </table>
  </dd>
</dl>
<p>Use this version only when you want to push a copy of the item arg onto the innternal queue because maybe you want to use item afterwards.</p>
<p>This option is not as efficient as the first version of Push because move semantics are not enforced. </p>

</div>
</div>
<a id="a71a86f55f3471566151aef7e9eee5ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a86f55f3471566151aef7e9eee5ccd">&#9670;&nbsp;</a></span>Size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::Size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of items on the queue. </dd></dl>

</div>
</div>
<a id="af860cec5b94be5c143d4df77a7caa39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af860cec5b94be5c143d4df77a7caa39f">&#9670;&nbsp;</a></span>TakeAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a1146e87353baead8d86048cd3f6f2a7e">container_type</a> <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::TakeAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take all items from the queue and return them, thus clearing down the internal queue. </p>
<p>If this method is called while a thread is blocking on the item event then due to interleving of calls and mutex lock timings this may cause the list to be cleared before a waiting pop function has had a chance to pop anything from the queue. This is safe but what it means is the pop function will not find anything to pop and will either throw or return false to indicate that nothing was popped off the queue. </p>

</div>
</div>
<a id="a2e80977a24adce8baf939a395a975f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e80977a24adce8baf939a395a975f19">&#9670;&nbsp;</a></span>TimedPop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::TimedPop </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeoutMilliseconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop an item off the queue but only wait for a given amount of time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMilliseconds</td><td>- Amount of time to wait. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>- The popped item, only valid if returns true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if item popped successfully, false if timed out. </dd></dl>

</div>
</div>
<a id="a4363dd5fe2e0ee2be4d7cc724699a3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4363dd5fe2e0ee2be4d7cc724699a3f5">&#9670;&nbsp;</a></span>TimedPopThrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::TimedPopThrow </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeoutMilliseconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop an item off the queue but only wait for a given amount of time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMilliseconds</td><td>- Amount of time to wait. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>- The popped item.</td></tr>
  </table>
  </dd>
</dl>
<p>If no items have been put onto the queue after the specified amount to time then a std::runtime_error exception is throw. </p>

</div>
</div>
<a id="aa24340e08122e91037bbc84d2fdc50b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24340e08122e91037bbc84d2fdc50b4">&#9670;&nbsp;</a></span>TryPop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::TryPop </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop an item off the queue if there are any else return. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>- The popped item, only valid if returns true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if item popped off queue, false otherwise. </dd></dl>

</div>
</div>
<a id="a518d08e42fdb9613733ac572fcaa4ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518d08e42fdb9613733ac572fcaa4ecf">&#9670;&nbsp;</a></span>TryPopThrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::TryPopThrow </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop an item off the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>- The popped item.</td></tr>
  </table>
  </dd>
</dl>
<p>This will throw std::runtime_error if there are no items on the queue when called. </p>

</div>
</div>
<a id="a17a1929f773384c559a3c0bb991255b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a1929f773384c559a3c0bb991255b0">&#9670;&nbsp;</a></span>TrySteal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::TrySteal </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Steal an item from the back of the queue if there are any else return. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>- The stolen item, only valid if returns true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if item stolen off queue, false otherwise. </dd></dl>

</div>
</div>
<a id="a8c6ec6f4828d9bafc2d6bd510ef62e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6ec6f4828d9bafc2d6bd510ef62e1b">&#9670;&nbsp;</a></span>TryStealThrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::TryStealThrow </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Steal an item from the back of the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>- The stolen item.</td></tr>
  </table>
  </dd>
</dl>
<p>This will throw std::runtime_error if there are no items on the queue when called. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3f4eb3c57b9cf483da061255555ae0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4eb3c57b9cf483da061255555ae0b0">&#9670;&nbsp;</a></span>m_itemEvent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html">SyncEvent</a> <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::m_itemEvent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">        eNotifyType::signalOneThread, eResetCondition::manualReset, eIntialCondition::notSignalled}</div></div><!-- fragment -->
<p>Synchronization event. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/run/media/duncanc/dc635e9e-d98f-45f8-96c6-fc6f6ae5c72e/projects/CoreLibrary/Include/Threads/<a class="el" href="_concurrent_queue_8h_source.html">ConcurrentQueue.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecore__lib.html">core_lib</a></li><li class="navelem"><a class="el" href="namespacecore__lib_1_1threads.html">threads</a></li><li class="navelem"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">ConcurrentQueue</a></li>
    <li class="footer">Generated on Sat Oct 27 2018 12:07:15 for Core Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
