<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Core Library: core_lib::threads::ConcurrentQueue&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Core Library
   &#160;<span id="projectnumber">1.4.0.0</span>
   </div>
   <div id="projectbrief">Library containing core utilities and tools for threading, networking, logging etc.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcore__lib_1_1threads_1_1_concurrent_queue.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classcore__lib_1_1threads_1_1_concurrent_queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">core_lib::threads::ConcurrentQueue&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class defining a concurrent queue.  
 <a href="classcore__lib_1_1threads_1_1_concurrent_queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_concurrent_queue_8h_source.html">ConcurrentQueue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a26fb2097dfdc6b2a358dc4f259e64256"><td class="memItemLeft" align="right" valign="top"><a id="a26fb2097dfdc6b2a358dc4f259e64256"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a26fb2097dfdc6b2a358dc4f259e64256">ConcurrentQueue</a> ()</td></tr>
<tr class="memdesc:a26fb2097dfdc6b2a358dc4f259e64256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a26fb2097dfdc6b2a358dc4f259e64256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f99f517b6c4ac7ca74e64fbedfe4ef"><td class="memItemLeft" align="right" valign="top"><a id="ac4f99f517b6c4ac7ca74e64fbedfe4ef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#ac4f99f517b6c4ac7ca74e64fbedfe4ef">ConcurrentQueue</a> (const <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">ConcurrentQueue</a> &amp;)=delete</td></tr>
<tr class="memdesc:ac4f99f517b6c4ac7ca74e64fbedfe4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor deleted. <br /></td></tr>
<tr class="separator:ac4f99f517b6c4ac7ca74e64fbedfe4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb24f09bc37cc42ba84391d7a57d6d52"><td class="memItemLeft" align="right" valign="top"><a id="acb24f09bc37cc42ba84391d7a57d6d52"></a>
<a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">ConcurrentQueue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#acb24f09bc37cc42ba84391d7a57d6d52">operator=</a> (const <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">ConcurrentQueue</a> &amp;)=delete</td></tr>
<tr class="memdesc:acb24f09bc37cc42ba84391d7a57d6d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator deleted. <br /></td></tr>
<tr class="separator:acb24f09bc37cc42ba84391d7a57d6d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f3df82263ff6c7e1fbb1b4053569a2"><td class="memItemLeft" align="right" valign="top"><a id="a26f3df82263ff6c7e1fbb1b4053569a2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a26f3df82263ff6c7e1fbb1b4053569a2">~ConcurrentQueue</a> ()</td></tr>
<tr class="memdesc:a26f3df82263ff6c7e1fbb1b4053569a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a26f3df82263ff6c7e1fbb1b4053569a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a86f55f3471566151aef7e9eee5ccd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a71a86f55f3471566151aef7e9eee5ccd">Size</a> () const</td></tr>
<tr class="memdesc:a71a86f55f3471566151aef7e9eee5ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the queue.  <a href="#a71a86f55f3471566151aef7e9eee5ccd">More...</a><br /></td></tr>
<tr class="separator:a71a86f55f3471566151aef7e9eee5ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03344656e7e1eedeea32a16d2695990c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a03344656e7e1eedeea32a16d2695990c">Empty</a> () const</td></tr>
<tr class="memdesc:a03344656e7e1eedeea32a16d2695990c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the queue empty.  <a href="#a03344656e7e1eedeea32a16d2695990c">More...</a><br /></td></tr>
<tr class="separator:a03344656e7e1eedeea32a16d2695990c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc992f1ab10e46088b4190437a5e36b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#afc992f1ab10e46088b4190437a5e36b6">Push</a> (T &amp;&amp;item)</td></tr>
<tr class="memdesc:afc992f1ab10e46088b4190437a5e36b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an item onto the queue.  <a href="#afc992f1ab10e46088b4190437a5e36b6">More...</a><br /></td></tr>
<tr class="separator:afc992f1ab10e46088b4190437a5e36b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3d0e1d8a6dfc60c9f2c5205f12d8c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a7f3d0e1d8a6dfc60c9f2c5205f12d8c5">BreakPopWait</a> ()</td></tr>
<tr class="memdesc:a7f3d0e1d8a6dfc60c9f2c5205f12d8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Break out of waiting on a Pop method.  <a href="#a7f3d0e1d8a6dfc60c9f2c5205f12d8c5">More...</a><br /></td></tr>
<tr class="separator:a7f3d0e1d8a6dfc60c9f2c5205f12d8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0739eb098119d7db6a3e78eb35c2cf2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#ab0739eb098119d7db6a3e78eb35c2cf2">Pop</a> (T &amp;item)</td></tr>
<tr class="memdesc:ab0739eb098119d7db6a3e78eb35c2cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an item off the queue if there are any else wait.  <a href="#ab0739eb098119d7db6a3e78eb35c2cf2">More...</a><br /></td></tr>
<tr class="separator:ab0739eb098119d7db6a3e78eb35c2cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa005fa06cdf70eca7c2f2187811b2a84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#aa005fa06cdf70eca7c2f2187811b2a84">PopThrow</a> (T &amp;item)</td></tr>
<tr class="memdesc:aa005fa06cdf70eca7c2f2187811b2a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an item off the queue if there are any else wait.  <a href="#aa005fa06cdf70eca7c2f2187811b2a84">More...</a><br /></td></tr>
<tr class="separator:aa005fa06cdf70eca7c2f2187811b2a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24340e08122e91037bbc84d2fdc50b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#aa24340e08122e91037bbc84d2fdc50b4">TryPop</a> (T &amp;item)</td></tr>
<tr class="memdesc:aa24340e08122e91037bbc84d2fdc50b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an item off the queue if there are any else return.  <a href="#aa24340e08122e91037bbc84d2fdc50b4">More...</a><br /></td></tr>
<tr class="separator:aa24340e08122e91037bbc84d2fdc50b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518d08e42fdb9613733ac572fcaa4ecf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a518d08e42fdb9613733ac572fcaa4ecf">TryPopThrow</a> (T &amp;item)</td></tr>
<tr class="memdesc:a518d08e42fdb9613733ac572fcaa4ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an item off the queue.  <a href="#a518d08e42fdb9613733ac572fcaa4ecf">More...</a><br /></td></tr>
<tr class="separator:a518d08e42fdb9613733ac572fcaa4ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8ab138639410e4e314c9890458ae34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#aed8ab138639410e4e314c9890458ae34">TimedPop</a> (const unsigned int timeoutMilliseconds, T &amp;item)</td></tr>
<tr class="memdesc:aed8ab138639410e4e314c9890458ae34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an item off the queue but only wait for a given amount of time.  <a href="#aed8ab138639410e4e314c9890458ae34">More...</a><br /></td></tr>
<tr class="separator:aed8ab138639410e4e314c9890458ae34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae058092f8f616ecf14145db7cc3a7429"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#ae058092f8f616ecf14145db7cc3a7429">TimedPopThrow</a> (const unsigned int timeoutMilliseconds, T &amp;item)</td></tr>
<tr class="memdesc:ae058092f8f616ecf14145db7cc3a7429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an item off the queue but only wait for a given amount of time.  <a href="#ae058092f8f616ecf14145db7cc3a7429">More...</a><br /></td></tr>
<tr class="separator:ae058092f8f616ecf14145db7cc3a7429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a1929f773384c559a3c0bb991255b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a17a1929f773384c559a3c0bb991255b0">TrySteal</a> (T &amp;item)</td></tr>
<tr class="memdesc:a17a1929f773384c559a3c0bb991255b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Steal an item from the back of the queue if there are any else return.  <a href="#a17a1929f773384c559a3c0bb991255b0">More...</a><br /></td></tr>
<tr class="separator:a17a1929f773384c559a3c0bb991255b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6ec6f4828d9bafc2d6bd510ef62e1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a8c6ec6f4828d9bafc2d6bd510ef62e1b">TryStealThrow</a> (T &amp;item)</td></tr>
<tr class="memdesc:a8c6ec6f4828d9bafc2d6bd510ef62e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Steal an item from the back of the queue.  <a href="#a8c6ec6f4828d9bafc2d6bd510ef62e1b">More...</a><br /></td></tr>
<tr class="separator:a8c6ec6f4828d9bafc2d6bd510ef62e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4435a528767e3bdea3ec43ef75bb7ac0"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a4435a528767e3bdea3ec43ef75bb7ac0">Peek</a> (const size_t index) const</td></tr>
<tr class="memdesc:a4435a528767e3bdea3ec43ef75bb7ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a peek at an item at a given index on the queue.  <a href="#a4435a528767e3bdea3ec43ef75bb7ac0">More...</a><br /></td></tr>
<tr class="separator:a4435a528767e3bdea3ec43ef75bb7ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dad5b5d8a631dbe9151432494144e90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a3dad5b5d8a631dbe9151432494144e90">Clear</a> ()</td></tr>
<tr class="memdesc:a3dad5b5d8a631dbe9151432494144e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the queue.  <a href="#a3dad5b5d8a631dbe9151432494144e90">More...</a><br /></td></tr>
<tr class="separator:a3dad5b5d8a631dbe9151432494144e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a2cdf8c31f8359021a9fdbf3a10d46c66"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a2cdf8c31f8359021a9fdbf3a10d46c66">eQueueEnd</a> { <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a2cdf8c31f8359021a9fdbf3a10d46c66ae6ec529ba185279aa0adcf93e645c7cd">eQueueEnd::front</a>, 
<a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a2cdf8c31f8359021a9fdbf3a10d46c66a469bba0a564235dfceede42db14f17b0">eQueueEnd::back</a>
 }<tr class="memdesc:a2cdf8c31f8359021a9fdbf3a10d46c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration controlling end of queue to pop from.  <a href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a2cdf8c31f8359021a9fdbf3a10d46c66">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a2cdf8c31f8359021a9fdbf3a10d46c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a9c75e4422397aa5cf01edf00f3537"><td class="memItemLeft" align="right" valign="top"><a id="a50a9c75e4422397aa5cf01edf00f3537"></a>
typedef std::deque&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a50a9c75e4422397aa5cf01edf00f3537">container_type</a></td></tr>
<tr class="memdesc:a50a9c75e4422397aa5cf01edf00f3537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for container type. <br /></td></tr>
<tr class="separator:a50a9c75e4422397aa5cf01edf00f3537"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aa9506ef787e44f5c9e1aec0c7a0a305b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#aa9506ef787e44f5c9e1aec0c7a0a305b">PopNow</a> (T &amp;item, const <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a2cdf8c31f8359021a9fdbf3a10d46c66">eQueueEnd</a> whichEnd=<a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a2cdf8c31f8359021a9fdbf3a10d46c66ae6ec529ba185279aa0adcf93e645c7cd">eQueueEnd::front</a>)</td></tr>
<tr class="memdesc:aa9506ef787e44f5c9e1aec0c7a0a305b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an item off the queue.  <a href="#aa9506ef787e44f5c9e1aec0c7a0a305b">More...</a><br /></td></tr>
<tr class="separator:aa9506ef787e44f5c9e1aec0c7a0a305b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30195c516adef0e3d84759b051bf5bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#ac30195c516adef0e3d84759b051bf5bd">PopFront</a> (T &amp;item)</td></tr>
<tr class="memdesc:ac30195c516adef0e3d84759b051bf5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an item off the front of the queue.  <a href="#ac30195c516adef0e3d84759b051bf5bd">More...</a><br /></td></tr>
<tr class="separator:ac30195c516adef0e3d84759b051bf5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a808f24042f3f48be0fd94b67ca5e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a69a808f24042f3f48be0fd94b67ca5e4">PopBack</a> (T &amp;item)</td></tr>
<tr class="memdesc:a69a808f24042f3f48be0fd94b67ca5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an item off the back of the queue.  <a href="#a69a808f24042f3f48be0fd94b67ca5e4">More...</a><br /></td></tr>
<tr class="separator:a69a808f24042f3f48be0fd94b67ca5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a295b3ba933953eddcc810a4fdbd83583"><td class="memItemLeft" align="right" valign="top"><a id="a295b3ba933953eddcc810a4fdbd83583"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a295b3ba933953eddcc810a4fdbd83583">m_mutex</a></td></tr>
<tr class="memdesc:a295b3ba933953eddcc810a4fdbd83583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronization mutex. <br /></td></tr>
<tr class="separator:a295b3ba933953eddcc810a4fdbd83583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4eb3c57b9cf483da061255555ae0b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html">SyncEvent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a3f4eb3c57b9cf483da061255555ae0b0">m_itemEvent</a></td></tr>
<tr class="memdesc:a3f4eb3c57b9cf483da061255555ae0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronization event.  <a href="#a3f4eb3c57b9cf483da061255555ae0b0">More...</a><br /></td></tr>
<tr class="separator:a3f4eb3c57b9cf483da061255555ae0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4be4f826b0a554e2d36bdf3d7a2029"><td class="memItemLeft" align="right" valign="top"><a id="a9d4be4f826b0a554e2d36bdf3d7a2029"></a>
<a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a50a9c75e4422397aa5cf01edf00f3537">container_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a9d4be4f826b0a554e2d36bdf3d7a2029">m_queue</a></td></tr>
<tr class="memdesc:a9d4be4f826b0a554e2d36bdf3d7a2029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying deque container acting as the queue. <br /></td></tr>
<tr class="separator:a9d4be4f826b0a554e2d36bdf3d7a2029"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class core_lib::threads::ConcurrentQueue&lt; T &gt;</h3>

<p>Class defining a concurrent queue. </p>
<p>This class implements a fully thread-safe queue that can be used with single/multiple producer thread(s) and single/multiple consumer thread(s).</p>
<p>It is up to the caller to make sure individual queue items get deallocated correctly. Preferably by using RAII objects as queue items or wrapping underlying data in std::shared_ptr (using a custom deallocator if necessary - see example custom deleters: <a class="el" href="structcore__lib_1_1threads_1_1_single_item_deleter.html" title="Single item deleter for queue item. ">SingleItemDeleter</a> and <a class="el" href="structcore__lib_1_1threads_1_1_array_deleter.html" title="Array deleter for queue item. ">ArrayDeleter</a>).</p>
<p>The template T must be a copyable and movable type. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a2cdf8c31f8359021a9fdbf3a10d46c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdf8c31f8359021a9fdbf3a10d46c66">&#9670;&nbsp;</a></span>eQueueEnd</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a2cdf8c31f8359021a9fdbf3a10d46c66">core_lib::threads::ConcurrentQueue::eQueueEnd</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration controlling end of queue to pop from. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2cdf8c31f8359021a9fdbf3a10d46c66ae6ec529ba185279aa0adcf93e645c7cd"></a>front&#160;</td><td class="fielddoc"><p>Pop front of the queue. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2cdf8c31f8359021a9fdbf3a10d46c66a469bba0a564235dfceede42db14f17b0"></a>back&#160;</td><td class="fielddoc"><p>Pop back of the queue. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7f3d0e1d8a6dfc60c9f2c5205f12d8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3d0e1d8a6dfc60c9f2c5205f12d8c5">&#9670;&nbsp;</a></span>BreakPopWait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::BreakPopWait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Break out of waiting on a Pop method. </p>
<p>Useful to force consumer(s) to break out of wait on Pop etc. </p>

</div>
</div>
<a id="a3dad5b5d8a631dbe9151432494144e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dad5b5d8a631dbe9151432494144e90">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the queue. </p>
<p>The method should only be called when no threads are blocked on any of the pop methods. If the queue items are unmanaged e.g. raw pointers then the user should instead individually pop each item off the queue and destroy it appropriately. If not then calling this method will result in leaked memory. </p>

</div>
</div>
<a id="a03344656e7e1eedeea32a16d2695990c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03344656e7e1eedeea32a16d2695990c">&#9670;&nbsp;</a></span>Empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::Empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the queue empty. </p>
<dl class="section return"><dt>Returns</dt><dd>True if empty, false otherwise. </dd></dl>

</div>
</div>
<a id="a4435a528767e3bdea3ec43ef75bb7ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4435a528767e3bdea3ec43ef75bb7ac0">&#9670;&nbsp;</a></span>Peek()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::Peek </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take a peek at an item at a given index on the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- Zero-based index of the queue item to peek at. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const pointer to item on queue being peeked at.</dd></dl>
<p>This method returns a nullptr if the index does not exist in the queue. The use of this method can be dangerous if there are multiple consumers. or if there is a single consumer but the method is called from a different thread to the consumer. </p>

</div>
</div>
<a id="ab0739eb098119d7db6a3e78eb35c2cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0739eb098119d7db6a3e78eb35c2cf2">&#9670;&nbsp;</a></span>Pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::Pop </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop an item off the queue if there are any else wait. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>- The popped item, only valid if returns true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if item popped off queue, false otherwise.</dd></dl>
<p>Method will block forever or until an item is placed on the queue. </p>

</div>
</div>
<a id="a69a808f24042f3f48be0fd94b67ca5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a808f24042f3f48be0fd94b67ca5e4">&#9670;&nbsp;</a></span>PopBack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::PopBack </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop an item off the back of the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>- Item popped off back. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac30195c516adef0e3d84759b051bf5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30195c516adef0e3d84759b051bf5bd">&#9670;&nbsp;</a></span>PopFront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::PopFront </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop an item off the front of the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>- Item popped off front. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9506ef787e44f5c9e1aec0c7a0a305b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9506ef787e44f5c9e1aec0c7a0a305b">&#9670;&nbsp;</a></span>PopNow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::PopNow </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a2cdf8c31f8359021a9fdbf3a10d46c66">eQueueEnd</a>&#160;</td>
          <td class="paramname"><em>whichEnd</em> = <code><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html#a2cdf8c31f8359021a9fdbf3a10d46c66ae6ec529ba185279aa0adcf93e645c7cd">eQueueEnd::front</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop an item off the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>- Item popped off queue. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">whichEnd</td><td>- WHich end of queue tp pop from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if not empty, false if queue empty. </dd></dl>

</div>
</div>
<a id="aa005fa06cdf70eca7c2f2187811b2a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa005fa06cdf70eca7c2f2187811b2a84">&#9670;&nbsp;</a></span>PopThrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::PopThrow </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop an item off the queue if there are any else wait. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>- The popped item, only valid if returns true.</td></tr>
  </table>
  </dd>
</dl>
<p>Method will block forever or until an item is placed on the queue.</p>
<p>This will throw <a class="el" href="classcore__lib_1_1threads_1_1x_queue_pop_queue_empty_error.html" title="Pop queue empty exception. ">xQueuePopQueueEmptyError</a> if there are no items on the queue when called. </p>

</div>
</div>
<a id="afc992f1ab10e46088b4190437a5e36b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc992f1ab10e46088b4190437a5e36b6">&#9670;&nbsp;</a></span>Push()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::Push </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push an item onto the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">item</td><td>- Object of type T to push onto queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71a86f55f3471566151aef7e9eee5ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a86f55f3471566151aef7e9eee5ccd">&#9670;&nbsp;</a></span>Size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::Size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of items on the queue. </dd></dl>

</div>
</div>
<a id="aed8ab138639410e4e314c9890458ae34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8ab138639410e4e314c9890458ae34">&#9670;&nbsp;</a></span>TimedPop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::TimedPop </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>timeoutMilliseconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop an item off the queue but only wait for a given amount of time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMilliseconds</td><td>- Amount of time to wait. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>- The popped item, only valid if returns true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if item popped successfully, false if timed out. </dd></dl>

</div>
</div>
<a id="ae058092f8f616ecf14145db7cc3a7429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae058092f8f616ecf14145db7cc3a7429">&#9670;&nbsp;</a></span>TimedPopThrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::TimedPopThrow </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>timeoutMilliseconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop an item off the queue but only wait for a given amount of time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMilliseconds</td><td>- Amount of time to wait. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>- The popped item.</td></tr>
  </table>
  </dd>
</dl>
<p>If no items have been put onto the queue after the specified amount to time then a <a class="el" href="classcore__lib_1_1threads_1_1x_queue_pop_timeout_error.html" title="Pop timeout exception. ">xQueuePopTimeoutError</a> exception is throw. </p>

</div>
</div>
<a id="aa24340e08122e91037bbc84d2fdc50b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24340e08122e91037bbc84d2fdc50b4">&#9670;&nbsp;</a></span>TryPop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::TryPop </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop an item off the queue if there are any else return. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>- The popped item, only valid if returns true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if item popped off queue, false otherwise. </dd></dl>

</div>
</div>
<a id="a518d08e42fdb9613733ac572fcaa4ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518d08e42fdb9613733ac572fcaa4ecf">&#9670;&nbsp;</a></span>TryPopThrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::TryPopThrow </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop an item off the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>- The popped item.</td></tr>
  </table>
  </dd>
</dl>
<p>This will throw <a class="el" href="classcore__lib_1_1threads_1_1x_queue_pop_queue_empty_error.html" title="Pop queue empty exception. ">xQueuePopQueueEmptyError</a> if there are no items on the queue when called. </p>

</div>
</div>
<a id="a17a1929f773384c559a3c0bb991255b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a1929f773384c559a3c0bb991255b0">&#9670;&nbsp;</a></span>TrySteal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::TrySteal </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Steal an item from the back of the queue if there are any else return. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>- The stolen item, only valid if returns true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if item stolen off queue, false otherwise. </dd></dl>

</div>
</div>
<a id="a8c6ec6f4828d9bafc2d6bd510ef62e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6ec6f4828d9bafc2d6bd510ef62e1b">&#9670;&nbsp;</a></span>TryStealThrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::TryStealThrow </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Steal an item from the back of the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>- The stolen item.</td></tr>
  </table>
  </dd>
</dl>
<p>This will throw <a class="el" href="classcore__lib_1_1threads_1_1x_queue_pop_queue_empty_error.html" title="Pop queue empty exception. ">xQueuePopQueueEmptyError</a> if there are no items on the queue when called. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3f4eb3c57b9cf483da061255555ae0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4eb3c57b9cf483da061255555ae0b0">&#9670;&nbsp;</a></span>m_itemEvent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html">SyncEvent</a> <a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">core_lib::threads::ConcurrentQueue</a>&lt; T &gt;::m_itemEvent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">        eNotifyType::signalOneThread, eResetCondition::manualReset, eIntialCondition::notSignalled}</div></div><!-- fragment -->
<p>Synchronization event. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>D:/Projects/CoreLibrary/Include/Threads/<a class="el" href="_concurrent_queue_8h_source.html">ConcurrentQueue.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecore__lib.html">core_lib</a></li><li class="navelem"><a class="el" href="namespacecore__lib_1_1threads.html">threads</a></li><li class="navelem"><a class="el" href="classcore__lib_1_1threads_1_1_concurrent_queue.html">ConcurrentQueue</a></li>
    <li class="footer">Generated on Thu May 4 2017 23:00:24 for Core Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
