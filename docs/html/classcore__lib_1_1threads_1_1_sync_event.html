<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Core Library: core_lib::threads::SyncEvent Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Core Library
   &#160;<span id="projectnumber">1.4.3.0</span>
   </div>
   <div id="projectbrief">Library containing core utilities and tools for threading, networking, logging etc.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcore__lib_1_1threads_1_1_sync_event.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classcore__lib_1_1threads_1_1_sync_event-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">core_lib::threads::SyncEvent Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class defining a thread synchronisation event.  
 <a href="classcore__lib_1_1threads_1_1_sync_event.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_sync_event_8h_source.html">SyncEvent.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5fc8409d6250a6641da4cc2e8eba0e03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html#a5fc8409d6250a6641da4cc2e8eba0e03">SyncEvent</a> ()=default</td></tr>
<tr class="memdesc:a5fc8409d6250a6641da4cc2e8eba0e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a5fc8409d6250a6641da4cc2e8eba0e03">More...</a><br /></td></tr>
<tr class="separator:a5fc8409d6250a6641da4cc2e8eba0e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5f68d8f6b614c157554fa748e38405"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html#afd5f68d8f6b614c157554fa748e38405">SyncEvent</a> (const <a class="el" href="namespacecore__lib_1_1threads.html#a4e51ab7a1c890051fdb90e0bb0bbfbe9">eNotifyType</a> notifyCondition, const <a class="el" href="namespacecore__lib_1_1threads.html#abea524dad80e074336983c4bc02c65e5">eResetCondition</a> resetCondition, const <a class="el" href="namespacecore__lib_1_1threads.html#a164aacfa37b4690eccd1b6dae4ebd9dc">eIntialCondition</a> initialCondition)</td></tr>
<tr class="memdesc:afd5f68d8f6b614c157554fa748e38405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intialising constructor.  <a href="#afd5f68d8f6b614c157554fa748e38405">More...</a><br /></td></tr>
<tr class="separator:afd5f68d8f6b614c157554fa748e38405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db93de77ad9b5c58fdfd23c218bbf46"><td class="memItemLeft" align="right" valign="top"><a id="a0db93de77ad9b5c58fdfd23c218bbf46"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html#a0db93de77ad9b5c58fdfd23c218bbf46">~SyncEvent</a> ()=default</td></tr>
<tr class="memdesc:a0db93de77ad9b5c58fdfd23c218bbf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a0db93de77ad9b5c58fdfd23c218bbf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b960db33f2a0f3be4ad6b71321636b"><td class="memItemLeft" align="right" valign="top"><a id="a90b960db33f2a0f3be4ad6b71321636b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html#a90b960db33f2a0f3be4ad6b71321636b">SyncEvent</a> (const <a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html">SyncEvent</a> &amp;)=delete</td></tr>
<tr class="memdesc:a90b960db33f2a0f3be4ad6b71321636b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor - disabled. <br /></td></tr>
<tr class="separator:a90b960db33f2a0f3be4ad6b71321636b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32a22e1fd8754499652a42c4408f756"><td class="memItemLeft" align="right" valign="top"><a id="aa32a22e1fd8754499652a42c4408f756"></a>
<a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html">SyncEvent</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html#aa32a22e1fd8754499652a42c4408f756">operator=</a> (const <a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html">SyncEvent</a> &amp;)=delete</td></tr>
<tr class="memdesc:aa32a22e1fd8754499652a42c4408f756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator - disabled. <br /></td></tr>
<tr class="separator:aa32a22e1fd8754499652a42c4408f756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39659aa94a26245a59e5a7cbd202c54d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html#a39659aa94a26245a59e5a7cbd202c54d">Wait</a> ()</td></tr>
<tr class="memdesc:a39659aa94a26245a59e5a7cbd202c54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for event.  <a href="#a39659aa94a26245a59e5a7cbd202c54d">More...</a><br /></td></tr>
<tr class="separator:a39659aa94a26245a59e5a7cbd202c54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c3bc9ab7b6f3392389d1ce30905e86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html#a27c3bc9ab7b6f3392389d1ce30905e86">WaitForTime</a> (const size_t milliseconds)</td></tr>
<tr class="memdesc:a27c3bc9ab7b6f3392389d1ce30905e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for event for a period of time.  <a href="#a27c3bc9ab7b6f3392389d1ce30905e86">More...</a><br /></td></tr>
<tr class="separator:a27c3bc9ab7b6f3392389d1ce30905e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6f477806372d89bdef91b894b8b637"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html#a7c6f477806372d89bdef91b894b8b637">Signal</a> ()</td></tr>
<tr class="memdesc:a7c6f477806372d89bdef91b894b8b637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal event.  <a href="#a7c6f477806372d89bdef91b894b8b637">More...</a><br /></td></tr>
<tr class="separator:a7c6f477806372d89bdef91b894b8b637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08b2171ed3e3117a56bb5e90893300f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html#af08b2171ed3e3117a56bb5e90893300f">Reset</a> ()</td></tr>
<tr class="memdesc:af08b2171ed3e3117a56bb5e90893300f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset event.reset_condition.  <a href="#af08b2171ed3e3117a56bb5e90893300f">More...</a><br /></td></tr>
<tr class="separator:af08b2171ed3e3117a56bb5e90893300f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a15f4afcd0305a5adabb02166367442f7"><td class="memItemLeft" align="right" valign="top"><a id="a15f4afcd0305a5adabb02166367442f7"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html#a15f4afcd0305a5adabb02166367442f7">m_signalMutex</a></td></tr>
<tr class="memdesc:a15f4afcd0305a5adabb02166367442f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to lock access to members. <br /></td></tr>
<tr class="separator:a15f4afcd0305a5adabb02166367442f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4689e927b5355529b796a70da69b8674"><td class="memItemLeft" align="right" valign="top"><a id="a4689e927b5355529b796a70da69b8674"></a>
std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html#a4689e927b5355529b796a70da69b8674">m_signalCondVar</a></td></tr>
<tr class="memdesc:a4689e927b5355529b796a70da69b8674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition vairable to perform the waiting and signalling. <br /></td></tr>
<tr class="separator:a4689e927b5355529b796a70da69b8674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18a113f8da3c90b74da5dc83b4bda29"><td class="memItemLeft" align="right" valign="top"><a id="ac18a113f8da3c90b74da5dc83b4bda29"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html#ac18a113f8da3c90b74da5dc83b4bda29">m_signalAllThreads</a> {}</td></tr>
<tr class="memdesc:ac18a113f8da3c90b74da5dc83b4bda29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal type flag. <br /></td></tr>
<tr class="separator:ac18a113f8da3c90b74da5dc83b4bda29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14e26bba7752e3c6a950d15d37ebff3"><td class="memItemLeft" align="right" valign="top"><a id="ab14e26bba7752e3c6a950d15d37ebff3"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html#ab14e26bba7752e3c6a950d15d37ebff3">m_autoReset</a> {true}</td></tr>
<tr class="memdesc:ab14e26bba7752e3c6a950d15d37ebff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto-reset flag. <br /></td></tr>
<tr class="separator:ab14e26bba7752e3c6a950d15d37ebff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec72c472512771facf219e362b829db"><td class="memItemLeft" align="right" valign="top"><a id="a1ec72c472512771facf219e362b829db"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html#a1ec72c472512771facf219e362b829db">m_signalFlag</a> {}</td></tr>
<tr class="memdesc:a1ec72c472512771facf219e362b829db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal flag. <br /></td></tr>
<tr class="separator:a1ec72c472512771facf219e362b829db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class defining a thread synchronisation event. </p>
<p>This class implemented a thread syncronisation event that is built using a mutex and a condition variable it makes for a neater implementation than using these types of object as is. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5fc8409d6250a6641da4cc2e8eba0e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc8409d6250a6641da4cc2e8eba0e03">&#9670;&nbsp;</a></span>SyncEvent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core_lib::threads::SyncEvent::SyncEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Create the <a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html" title="Class defining a thread synchronisation event. ">SyncEvent</a> in auto-reset mode, signaling one thread at a time and initially in a not signalled state. </p>

</div>
</div>
<a id="afd5f68d8f6b614c157554fa748e38405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5f68d8f6b614c157554fa748e38405">&#9670;&nbsp;</a></span>SyncEvent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">core_lib::threads::SyncEvent::SyncEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecore__lib_1_1threads.html#a4e51ab7a1c890051fdb90e0bb0bbfbe9">eNotifyType</a>&#160;</td>
          <td class="paramname"><em>notifyCondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecore__lib_1_1threads.html#abea524dad80e074336983c4bc02c65e5">eResetCondition</a>&#160;</td>
          <td class="paramname"><em>resetCondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecore__lib_1_1threads.html#a164aacfa37b4690eccd1b6dae4ebd9dc">eIntialCondition</a>&#160;</td>
          <td class="paramname"><em>initialCondition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intialising constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">notifyCondition</td><td>- Notify type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resetCondition</td><td>- Reset condition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initialCondition</td><td>- Initial condition.</td></tr>
  </table>
  </dd>
</dl>
<p>Create the <a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html" title="Class defining a thread synchronisation event. ">SyncEvent</a> setting whether auto- or manual reset is to be used. Also setting whether when signalled it notifies all waiting threads or just one of them. Can also set the initial condition as signalled or not signalled.</p>
<p>If notifyCondition == eNotifyType::signalAllThreads then eResetCondition == eResetCondition::manualReset. This is because before you resue the event for signalling you must make sure all the signalled threads have finished their task(s) before the <a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html" title="Class defining a thread synchronisation event. ">SyncEvent</a> object is reset manually. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af08b2171ed3e3117a56bb5e90893300f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08b2171ed3e3117a56bb5e90893300f">&#9670;&nbsp;</a></span>Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void core_lib::threads::SyncEvent::Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset event.reset_condition. </p>
<p>Use this function when SYncEvent created in maunal reset mode. Call to reset the signalled state of the event. This should not be called while athread is blocked on a call to Wait or WaitForTime. This should be called after the event has been signalled and Wait or WaitFor Time has returned and before calling Wait or WaitForTime again. </p>

</div>
</div>
<a id="a7c6f477806372d89bdef91b894b8b637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6f477806372d89bdef91b894b8b637">&#9670;&nbsp;</a></span>Signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void core_lib::threads::SyncEvent::Signal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal event. </p>
<p>Call this function to signal the underlying condition variable. If a thread is blocked on a call to Wait or WaitForTime then the waiting function will unblock and return. </p>

</div>
</div>
<a id="a39659aa94a26245a59e5a7cbd202c54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39659aa94a26245a59e5a7cbd202c54d">&#9670;&nbsp;</a></span>Wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void core_lib::threads::SyncEvent::Wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for event. </p>
<p>Blocking function that waits until underlying condition variable is signalled at which point this function returns. </p>

</div>
</div>
<a id="a27c3bc9ab7b6f3392389d1ce30905e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c3bc9ab7b6f3392389d1ce30905e86">&#9670;&nbsp;</a></span>WaitForTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_lib::threads::SyncEvent::WaitForTime </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for event for a period of time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">milliseconds</td><td>- Number of milliseconds to wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if signalled, false if timed out.</dd></dl>
<p>Blocking function that waits until underlying condition variable is signalled at which point this function returns or if not signalled this function returns after a defined number of milliseconds. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>D:/Projects/CoreLibrary/Include/Threads/<a class="el" href="_sync_event_8h_source.html">SyncEvent.h</a></li>
<li>D:/Projects/CoreLibrary/Source/Threads/<a class="el" href="_sync_event_8cpp.html">SyncEvent.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecore__lib.html">core_lib</a></li><li class="navelem"><a class="el" href="namespacecore__lib_1_1threads.html">threads</a></li><li class="navelem"><a class="el" href="classcore__lib_1_1threads_1_1_sync_event.html">SyncEvent</a></li>
    <li class="footer">Generated on Sun May 28 2017 23:59:27 for Core Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
